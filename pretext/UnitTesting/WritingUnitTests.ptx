<?xml version="1.0"?>
<section xml:id="unit-testing_writing-unit-tests">
  <title>Writing Unit Tests</title>
  <p>Once you have designed a testable function, with a clear docstring specification, writing unit tests
            is not difficult. In this section, you'll learn how to do just that.</p>
  <p>Let's start with our <c>sumnums</c> function:</p>
  <pre>def sumnums(lo, hi):
    """computes the sum of a range of numbers

    Precondition: lo &lt;= hi
    Postcondition: returns the sum of the numbers in the range [lo..hi]
    """

    sum = 0
    for i in range(lo, hi+1):
        sum += i
    return sum</pre>
  <p>As we've seen, to write a unit test, you devise test cases for the function, and then write assert statements that call
            the function and check that the function produced the expected results. The following assert statements would be
            appropriate for a unit test for <c>sumnums</c>:</p>
  <pre>assert sumnums(1, 3) == 6
assert sumnums(1, 1) == 1</pre>
  <p>But what about the following?</p>
  <pre>assert sumnums(3, 1) == 0</pre>
  <p>Note that <c>sumnums</c> produces the value <c>0</c> for cases where the <c>lo</c> values exceeds the <c>hi</c> value, as is the
            case in this assert. So, like the first two asserts above, this assert would pass. However, it is not an
            appropriate assertion, because the specification says nothing about what the function produces if <c>lo</c> is greater than
            <c>hi</c>.</p>
  <p>The unit test should be written such that it passes even if the function implementation is altered in a way that
            causes some other value than 0 to be returned if <c>lo</c> exceeds <c>hi</c>. For example, we might want to redesign the
            function to be more efficient &#x2014; for example, use Gauss's formula for summing numbers, as in the following:</p>
  <pre>def sumnums(lo, hi):
    """computes the sum of a range of numbers

    Precondition: lo &lt;= hi
    Postcondition: returns the sum of the numbers in the range [lo..hi]
    """

    return (hi * (hi + 1) / 2) - (lo * (lo - 1) / 2)</pre>
  <p>This version will produce correct results if the precondition is satisfied. Like the original function, it produces
            incorrect results if the precondition is violated &#x2014; but unlike the original function, the values produced if the
            precondition is violated are not necessarily 0.</p>
  <subsection xml:id="unit-testing_specification-based-testing">
    <title>Specification-Based Testing</title>
    <p>A key idea to remember when writing a unit test is that your test must always respect the function's preconditions. The
                docstring states what the function should do, with the assumption that parameter values meet the preconditions. It does
                not state what the function should do if the parameter values violate the preconditions.</p>
    <p>Writing an assert that violates the functions preconditions is not a good idea, because to determine what the function
                will produce for that case, you must look into the implementation of the function and analyze its behavior. That is
                called <term>implementation-based testing</term>, and it leads to brittle tests that are likely to fail if you rework the
                function implementation. When you write tests are based only on the function specification, without looking at the
                implementation, you are doing specification-based testing.</p>
    <note>
      <title>Specification-Based Tests</title>
      <p>Specification-based tests are tests that are designed based only on the information in the function
                    specification, without considering any of the details in the function implementation.</p>
    </note>
    <p>Specification-based tests are preferred over implementation-based tests, because they are more resilient. They will continue
                to pass even if you rework the function implementation.</p>
    <p>
      <term>Check your understanding</term>
    </p>
    <exercise label="mc_designtests_1">
      <statement>
        <p>Consider the following function. Indicate which of the asserts would be
                appropriate for a unit test.</p>
        <program language="python">
          <input>
def repeat(s: str, num: int) -&gt; str:
    """duplicates a string

    Precondition: `num` &gt;= 0
    Postcondition: Returns a string containing `num` copies of `s`
    """
    if num &gt;= 0:
        return s * num
    else:
        return ''
</input>
        </program>
      </statement>
      <choices>
        <choice correct="yes">
          <statement>
            <p>assert repeat('*', 0) == ''</p>
          </statement>
          <feedback>
                    Correct. The specification indicates that the function should produce an empty string.
                </feedback>
        </choice>
        <choice>
          <statement>
            <p>assert repeat('*', -1) == ''</p>
          </statement>
          <feedback>
                    Incorrect. The parameter -1 violates the precondition, and such a test is inappropriate, even though the function would return an empty string in this case.
                </feedback>
        </choice>
        <choice correct="yes">
          <statement>
            <p>assert repeat('-', 5) == '-----'</p>
          </statement>
          <feedback>
                    Correct. The parameters satisfy the precondition and the value '-----' is appropriate given the postcondition.
                </feedback>
        </choice>
        <choice>
          <statement>
            <p>assert repeat('*', 5) == '***'</p>
          </statement>
          <feedback>
                    Incorrect. The string '***' does not conform to the postcondition.
                </feedback>
        </choice>
      </choices>
    </exercise>
    <exercise label="ac_grade_unittest">
      <statement>
        <p>Write assert statements below to test a function
                        with the following specification. Your asserts should
                        check that the function produces an appropriate value
                        for each of the three postcondition cases.</p>
        <program language="python">
          <input>
def grade(score):
    """Determines letter grade given a numeric score

    Precondition: 0 &lt;= `score` &lt;= 100
    Postcondition: Returns 'A' if 90 &lt;= `score` &lt;= 100,
      'B' if 80 &lt;= `score` &lt; 90, 'F' if 0 &lt;= `score` &lt; 80
    """
</input>
        </program>
        <p>Note: Line numbers in any assert error messages that appear while
                        you are developing and testing your answer will not be accurate.</p>
      </statement>
      <program interactive="activecode" language="python" xml:id="ac_grade_unittest_editor">
        <input>
# Write assert statements to test grade()


====
from unittest.gui import TestCaseGui

class myTests(TestCaseGui):

    def testOne(self):
        code = self.getEditorText().replace(' ','').replace('"', '').replace("'", '')
        self.assertTrue(testA and '==A' in code, "Assert tested 90..100")
        self.assertTrue(testB and '==B' in code, "Assert tested 80..90")
        self.assertTrue(testF and '==F' in code, "Assert tested 0..80")
        self.assertFalse(illegal, "No asserts violated preconditions")

myTests().main()
        </input>
      </program>
      <solution>
                    The following asserts are just some of several that could have been used.

    <program xml:id="ac_grade_unittest_sol" language="python"><input>
assert grade(92) == 'A'
assert grade(85) == 'B'
assert grade(69) == 'F'
        </input></program>
                    .. reveal:: ac_grade_unittest_aux_reveal
                    :instructoronly:
                    .. actex:: ac_grade_unittest_aux
                    testA = False
                    testB = False
                    testF = False
                    illegal = False
                    def grade(score):
                    global illegal, testA, testB, testF
                    if score &gt; 100 or score &lt; 0:
                    illegal = True
                    return ''
                    elif score &gt;= 90:
                    testA = True
                    return 'A'
                    elif score &gt;= 80:
                    testB = True
                    return 'B'
                    else:
                    testF = True
                    return 'F'
                
                    <p>The following asserts are just some of several that could have been used.</p>

    
                    <!--.. reveal:: ac_grade_unittest_aux_reveal-->
                    <!--:instructoronly:-->
                    <!--.. actex:: ac_grade_unittest_aux-->
                    <!--testA = False-->
                    <!--testB = False-->
                    <!--testF = False-->
                    <!--illegal = False-->
                    <!--def grade(score):-->
                    <!--global illegal, testA, testB, testF-->
                    <!--if score > 100 or score < 0:-->
                    <!--illegal = True-->
                    <!--return ''-->
                    <!--elif score >= 90:-->
                    <!--testA = True-->
                    <!--return 'A'-->
                    <!--elif score >= 80:-->
                    <!--testB = True-->
                    <!--return 'B'-->
                    <!--else:-->
                    <!--testF = True-->
                    <!--return 'F'-->
                </solution>
    </exercise>
  </subsection>
</section>
